<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IoT Middleware v3 - Complete Documentation</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }
        
        header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        header .version {
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        header .tagline {
            margin-top: 10px;
            font-size: 1.1em;
            font-style: italic;
        }
        
        nav {
            background: #f8f9fa;
            padding: 15px 40px;
            border-bottom: 2px solid #e9ecef;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        nav ul {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        nav a {
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
            padding: 8px 16px;
            border-radius: 5px;
            transition: all 0.3s;
        }
        
        nav a:hover {
            background: #667eea;
            color: white;
        }
        
        .content {
            padding: 40px;
        }
        
        section {
            margin-bottom: 60px;
            scroll-margin-top: 80px;
        }
        
        h2 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
        }
        
        h3 {
            color: #764ba2;
            font-size: 1.8em;
            margin: 30px 0 15px 0;
        }
        
        h4 {
            color: #555;
            font-size: 1.3em;
            margin: 20px 0 10px 0;
        }
        
        .info-box {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .success-box {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .mermaid {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }
        
        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
        }
        
        pre code {
            background: none;
            color: inherit;
            padding: 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border: 1px solid #ddd;
        }
        
        th {
            background: #667eea;
            color: white;
            font-weight: 600;
        }
        
        tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .feature-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
            transition: all 0.3s;
        }
        
        .feature-card:hover {
            border-color: #667eea;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
            transform: translateY(-5px);
        }
        
        .feature-card h4 {
            color: #667eea;
            margin-top: 0;
        }
        
        .endpoint {
            background: #f8f9fa;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #28a745;
        }
        
        .endpoint .method {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 4px;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .endpoint .get { background: #28a745; color: white; }
        .endpoint .post { background: #007bff; color: white; }
        .endpoint .put { background: #ffc107; color: black; }
        .endpoint .delete { background: #dc3545; color: white; }
        
        footer {
            background: #2d2d2d;
            color: white;
            text-align: center;
            padding: 30px;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
            margin: 0 5px;
        }
        
        .badge-primary { background: #667eea; color: white; }
        .badge-success { background: #28a745; color: white; }
        .badge-warning { background: #ffc107; color: black; }
        .badge-danger { background: #dc3545; color: white; }
        .badge-info { background: #17a2b8; color: white; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üöÄ IoT Middleware v3</h1>
            <div class="version">Version 3.0.0</div>
            <div class="tagline">MQTT to REST API Bridge with Real-time Processing</div>
            <div style="margin-top: 20px;">
                <span class="badge badge-success">Production Ready</span>
                <span class="badge badge-info">Event-Driven</span>
                <span class="badge badge-warning">High Performance</span>
            </div>
        </header>

        <nav>
            <ul>
                <li><a href="#overview">Overview</a></li>
                <li><a href="#interfaces">Interfaces</a></li>
                <li><a href="#config">Configuration</a></li>
                <li><a href="#structure">File Structure</a></li>
                <li><a href="#framework">Architecture</a></li>
                <li><a href="#message-flow">Message Flow</a></li>
                <li><a href="#dependencies">Dependencies</a></li>
                <li><a href="#scalability">Scalability</a></li>
            </ul>
        </nav>

        <div class="content">
            <!-- OVERVIEW SECTION -->
            <section id="overview">
                <h2>üìã Project Overview</h2>
                
                <div class="info-box">
                    <h3>What is IoT Middleware v3?</h3>
                    <p>IoT Middleware v3 is a high-performance, event-driven middleware solution that bridges IoT devices using MQTT protocol with REST API consumers. It provides real-time message processing, data normalization, persistent storage, and WebSocket broadcasting capabilities.</p>
                </div>

                <h3>Key Features</h3>
                <div class="feature-grid">
                    <div class="feature-card">
                        <h4>üîå MQTT Integration</h4>
                        <p>Subscribes to multiple MQTT topics with wildcard support. Handles reconnection, QoS levels, and message persistence.</p>
                    </div>
                    <div class="feature-card">
                        <h4>üîÑ Real-time Processing</h4>
                        <p>Event-driven architecture with middleware pipeline for message transformation and normalization.</p>
                    </div>
                    <div class="feature-card">
                        <h4>üíæ Data Persistence</h4>
                        <p>MySQL database integration with write buffering for optimal performance. Configurable batch inserts.</p>
                    </div>
                    <div class="feature-card">
                        <h4>‚ö° In-Memory Cache</h4>
                        <p>High-speed cache for latest device data with TTL and automatic eviction.</p>
                    </div>
                    <div class="feature-card">
                        <h4>üåê REST API</h4>
                        <p>RESTful endpoints for querying latest data, historical records, and system metrics.</p>
                    </div>
                    <div class="feature-card">
                        <h4>üì° WebSocket Support</h4>
                        <p>Real-time message broadcasting to connected WebSocket clients for live monitoring.</p>
                    </div>
                    <div class="feature-card">
                        <h4>üîî HTTP Callbacks</h4>
                        <p>Configurable HTTP callbacks to external services with retry logic and exponential backoff.</p>
                    </div>
                    <div class="feature-card">
                        <h4>üì® Message Relay</h4>
                        <p>Automatic message republishing to new MQTT topics with configurable prefix patterns.</p>
                    </div>
                </div>

                <h3>Technology Stack</h3>
                <table>
                    <tr>
                        <th>Component</th>
                        <th>Technology</th>
                        <th>Purpose</th>
                    </tr>
                    <tr>
                        <td>Runtime</td>
                        <td>Node.js</td>
                        <td>JavaScript runtime environment</td>
                    </tr>
                    <tr>
                        <td>Web Framework</td>
                        <td>Express.js</td>
                        <td>REST API and routing</td>
                    </tr>
                    <tr>
                        <td>MQTT Client</td>
                        <td>mqtt (npm)</td>
                        <td>MQTT protocol implementation</td>
                    </tr>
                    <tr>
                        <td>Database</td>
                        <td>MySQL 8.0+</td>
                        <td>Data persistence</td>
                    </tr>
                    <tr>
                        <td>DB Driver</td>
                        <td>mysql2</td>
                        <td>MySQL connection with promises</td>
                    </tr>
                    <tr>
                        <td>WebSocket</td>
                        <td>ws (npm)</td>
                        <td>Real-time bidirectional communication</td>
                    </tr>
                    <tr>
                        <td>HTTP Client</td>
                        <td>node-fetch</td>
                        <td>HTTP callbacks to external services</td>
                    </tr>
                </table>

                <div class="success-box">
                    <h4>‚úÖ Recent Bug Fixes (2025-10-01)</h4>
                    <ul>
                        <li>Fixed case sensitivity issue in module imports (Linux compatibility)</li>
                        <li>Added missing methods: getConnectedClientsCount() and getBufferSize()</li>
                        <li>Initialized WebSocketServer and CallbackManager components</li>
                        <li>Registered components with Express app for route access</li>
                        <li>Added node-fetch import to CallbackManager</li>
                        <li>Removed 8 orphaned/unused files for cleaner codebase</li>
                        <li>Added callbacks.enabled configuration flag</li>
                    </ul>
                </div>
            </section>

            <!-- INTERFACES SECTION -->
            <section id="interfaces">
                <h2>üîå Interfaces & Data Examples</h2>

                <h3>REST API Endpoints</h3>

                <div class="endpoint">
                    <span class="method get">GET</span>
                    <code>/</code>
                    <p>Redirects to about.html - Home page</p>
                </div>

                <div class="endpoint">
                    <span class="method get">GET</span>
                    <code>/system/health</code>
                    <p>Health check endpoint</p>
                    <strong>Response:</strong>
                    <pre><code>{
  "status": "healthy",
  "timestamp": "2025-10-01T11:30:00.000Z"
}</code></pre>
                </div>

                <div class="endpoint">
                    <span class="method get">GET</span>
                    <code>/system/metrics</code>
                    <p>System metrics including WebSocket clients, buffer size, memory, and CPU usage</p>
                    <strong>Response:</strong>
                    <pre><code>{
  "system": {
    "cpu": {
      "loadAvg": [1.2, 1.5, 1.3],
      "uptime": 345678
    },
    "memory": {
      "total": 16777216000,
      "free": 8388608000,
      "used": 8388608000
    }
  },
  "application": {
    "wsClients": 5,
    "writeBufferSize": 42,
    "uptime": 12345
  }
}</code></pre>
                </div>

                <div class="endpoint">
                    <span class="method get">GET</span>
                    <code>/api/latest</code>
                    <p>Get latest data for all devices</p>
                    <strong>Response:</strong>
                    <pre><code>{
  "sensor1": {
    "deviceId": "sensor1",
    "sensorType": "temperature",
    "ts": "2025-10-01T11:30:00.000Z",
    "seq": 1234,
    "payload": {
      "temp": 25.5,
      "unit": "C",
      "rackNo": 1,
      "posU": 2
    },
    "meta": {
      "rawTopic": "sensors/gateway123/temperature"
    }
  },
  "sensor2": {
    "deviceId": "sensor2",
    "sensorType": "temperature",
    "ts": "2025-10-01T11:29:45.000Z",
    "seq": 1235,
    "payload": {
      "temp": 22.3,
      "unit": "C"
    },
    "meta": {
      "rawTopic": "sensors/gateway456/temperature"
    }
  }
}</code></pre>
                </div>

                <div class="endpoint">
                    <span class="method get">GET</span>
                    <code>/api/latest/:deviceId</code>
                    <p>Get latest data for a specific device</p>
                    <strong>Example:</strong> <code>GET /api/latest/sensor1</code>
                    <strong>Response:</strong>
                    <pre><code>{
  "deviceId": "sensor1",
  "sensorType": "temperature",
  "ts": "2025-10-01T11:30:00.000Z",
  "seq": 1234,
  "payload": {
    "temp": 25.5,
    "unit": "C",
    "rackNo": 1,
    "posU": 2
  },
  "meta": {
    "rawTopic": "sensors/gateway123/temperature"
  }
}</code></pre>
                </div>

                <div class="endpoint">
                    <span class="method get">GET</span>
                    <code>/api/history/:deviceId?limit=50</code>
                    <p>Get historical data for a device (from database if enabled, otherwise from in-memory store)</p>
                    <strong>Example:</strong> <code>GET /api/history/sensor1?limit=10</code>
                    <strong>Response:</strong>
                    <pre><code>[
  {
    "device_id": "sensor1",
    "sensor_type": "temperature",
    "timestamp": "2025-10-01T11:30:00.000Z",
    "payload": {
      "temp": 25.5,
      "unit": "C"
    },
    "meta": {
      "rawTopic": "sensors/gateway123/temperature"
    },
    "created_at": "2025-10-01T11:30:00.000Z"
  },
  // ... more records
]</code></pre>
                </div>

                <h3>MQTT Message Format</h3>
                
                <h4>Incoming MQTT Message (Raw)</h4>
                <strong>Topic:</strong> <code>sensors/gateway123/temperature</code>
                <pre><code>{
  "devId": "sensor1",
  "tmp": 25.5,
  "unit": "C",
  "time": 1696154400000,
  "seq": 1234,
  "rackNo": 1,
  "posU": 2
}</code></pre>

                <h4>Normalized Message (After Processing)</h4>
                <pre><code>{
  "deviceId": "sensor1",
  "sensorType": "temperature",
  "ts": "2025-10-01T11:30:00.000Z",
  "seq": 1234,
  "payload": {
    "temp": 25.5,
    "unit": "C",
    "rackNo": 1,
    "posU": 2
  },
  "meta": {
    "rawTopic": "sensors/gateway123/temperature",
    "category": "sensors",
    "gatewayId": "gateway123",
    "type": "temperature"
  }
}</code></pre>

                <h3>WebSocket Communication</h3>
                <strong>Connection:</strong> <code>ws://localhost:3000</code>
                <p>WebSocket clients receive real-time messages in the normalized format shown above whenever a message is processed.</p>

                <h3>Message Relay (Optional)</h3>
                <p>When message relay is enabled, processed messages are automatically republished to new MQTT topics:</p>
                <strong>Original Topic:</strong> <code>sensors/gateway123/temperature</code><br>
                <strong>Relayed Topic:</strong> <code>sensors/new/gateway123/temperature</code>
            </section>

            <!-- CONFIGURATION SECTION -->
            <section id="config">
                <h2>‚öôÔ∏è Configuration</h2>

                <div class="info-box">
                    <p>Configuration is managed through two main files:</p>
                    <ul>
                        <li><code>.env</code> - Environment variables (database credentials, MQTT URL, etc.)</li>
                        <li><code>config/config.json</code> - Application settings</li>
                    </ul>
                </div>

                <h3>Environment Variables (.env)</h3>
                <pre><code># Server Configuration
PORT=3000
NODE_ENV=development

# MQTT Configuration
MQTT_URL=mqtt://localhost:1883

# Database Configuration
DB_HOST=localhost
DB_USER=root
DB_PASS=your_password
DB_NAME=iot_middleware

# Debug Mode
DEBUG=true</code></pre>

                <h3>Application Configuration (config.json)</h3>

                <h4>MQTT Settings</h4>
                <pre><code>{
  "mqtt": {
    "topics": ["sensors/#", "devices/#"],
    "options": {
      "qos": 1,
      "reconnectPeriod": 5000,
      "keepalive": 60
    },
    "patterns": {
      "sensors": "sensors/+/+",
      "devices": "devices/+/+"
    }
  }
}</code></pre>

                <h4>Cache Settings</h4>
                <pre><code>{
  "cache": {
    "enabled": true,
    "maxSize": 10000,
    "ttl": 3600000  // 1 hour in milliseconds
  }
}</code></pre>

                <h4>Write Buffer Settings</h4>
                <pre><code>{
  "writeBuffer": {
    "maxSize": 1000,      // Flush after 1000 messages
    "flushInterval": 5000, // Or every 5 seconds
    "maxRetries": 3
  }
}</code></pre>

                <h4>Database Settings</h4>
                <pre><code>{
  "database": {
    "enabled": true,
    "connectionPool": {
      "waitForConnections": true,
      "connectionLimit": 10,
      "queueLimit": 0
    }
  }
}</code></pre>

                <h4>Message Relay Settings</h4>
                <pre><code>{
  "messageRelay": {
    "enabled": true,
    "topicPrefix": "new",
    "patterns": {
      "sensors": "sensors/${prefix}/${gatewayId}/${type}",
      "devices": "devices/${prefix}/${gatewayId}/${type}"
    }
  }
}</code></pre>

                <h4>HTTP Callbacks Settings</h4>
                <pre><code>{
  "callbacks": {
    "enabled": false,  // Enable when needed
    "retryLimit": 3,
    "retryDelay": 1000  // Initial delay in milliseconds
  }
}</code></pre>

                <h4>Server Settings</h4>
                <pre><code>{
  "server": {
    "rateLimit": {
      "windowMs": 900000,    // 15 minutes
      "maxRequests": 100
    },
    "compression": {
      "level": 6,
      "threshold": "1kb"
    }
  }
}</code></pre>

                <div class="warning-box">
                    <h4>‚ö†Ô∏è Important Notes</h4>
                    <ul>
                        <li>Set <code>database.enabled: false</code> if you don't need persistence</li>
                        <li>Adjust <code>writeBuffer.maxSize</code> based on your message volume</li>
                        <li>Enable <code>callbacks</code> only when you have external services to notify</li>
                        <li>Use <code>DEBUG=true</code> in development for detailed logging</li>
                    </ul>
                </div>
            </section>

            <!-- FILE STRUCTURE SECTION -->
            <section id="structure">
                <h2>üìÅ File Structure</h2>

                <pre><code>iot-middleware/
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ config.json          # Application configuration
‚îÇ   ‚îú‚îÄ‚îÄ ConfigManager.js     # Singleton config manager
‚îÇ   ‚îú‚îÄ‚îÄ db.js               # Database connection (deprecated)
‚îÇ   ‚îî‚îÄ‚îÄ schema.sql          # Database schema
‚îÇ
‚îú‚îÄ‚îÄ modules/
‚îÇ   ‚îú‚îÄ‚îÄ Application.js      # Main application orchestrator
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CallbackManager.js    # HTTP callback handler
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ WebSocketServer.js    # WebSocket server
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BaseComponent.js      # Base class for all components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ eventBus.js           # Event emitter singleton
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ messageProcessor.js   # Middleware pipeline processor
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DatabaseManager.js    # MySQL operations & pooling
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ mqtt/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MQTTClient.js         # MQTT connection handler
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TopicManager.js       # Topic parsing & validation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ messageRelay.js       # Message republishing
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ normalizers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.js              # Normalizer registry
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ temperatureNormalizer.js  # Temperature data normalizer
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ plugins/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ messageEnrichment.js  # Example plugin (not active)
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ storage/
‚îÇ       ‚îú‚îÄ‚îÄ CacheManager.js       # In-memory cache with TTL
‚îÇ       ‚îú‚îÄ‚îÄ dataStore.js          # In-memory data store
‚îÇ       ‚îî‚îÄ‚îÄ WriteBuffer.js        # Batch write buffer
‚îÇ
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ api.js              # REST API routes
‚îÇ   ‚îú‚îÄ‚îÄ index.js            # Root routes
‚îÇ   ‚îî‚îÄ‚îÄ system.js           # System/health routes
‚îÇ
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ logger.js           # Console logger
‚îÇ   ‚îî‚îÄ‚îÄ loggerToFile.js     # File logger (not active)
‚îÇ
‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îú‚îÄ‚îÄ about.html          # Project overview page
‚îÇ   ‚îú‚îÄ‚îÄ about-latest.html   # This comprehensive documentation
‚îÇ   ‚îî‚îÄ‚îÄ *.html              # Other documentation pages
‚îÇ
‚îú‚îÄ‚îÄ .env                    # Environment variables
‚îú‚îÄ‚îÄ .gitignore             # Git ignore rules
‚îú‚îÄ‚îÄ package.json           # NPM dependencies
‚îú‚îÄ‚îÄ server.js              # Application entry point
‚îú‚îÄ‚îÄ BUG_REPORT.md          # Bug documentation
‚îî‚îÄ‚îÄ FIXES_APPLIED.md       # Fix documentation
</code></pre>

                <h3>Active Components Overview</h3>
                <table>
                    <tr>
                        <th>Module</th>
                        <th>Purpose</th>
                        <th>Status</th>
                    </tr>
                    <tr>
                        <td>Application.js</td>
                        <td>Main orchestrator, initializes all components</td>
                        <td><span class="badge badge-success">Active</span></td>
                    </tr>
                    <tr>
                        <td>MQTTClient.js</td>
                        <td>Connects to MQTT broker, handles subscriptions</td>
                        <td><span class="badge badge-success">Active</span></td>
                    </tr>
                    <tr>
                        <td>DatabaseManager.js</td>
                        <td>MySQL connection pooling and query execution</td>
                        <td><span class="badge badge-success">Active</span></td>
                    </tr>
                    <tr>
                        <td>WebSocketServer.js</td>
                        <td>Real-time broadcasting to connected clients</td>
                        <td><span class="badge badge-success">Active</span></td>
                    </tr>
                    <tr>
                        <td>CallbackManager.js</td>
                        <td>HTTP callbacks to external services</td>
                        <td><span class="badge badge-warning">Optional</span></td>
                    </tr>
                    <tr>
                        <td>MessageRelay.js</td>
                        <td>Republishes messages to new topics</td>
                        <td><span class="badge badge-info">Configurable</span></td>
                    </tr>
                    <tr>
                        <td>WriteBuffer.js</td>
                        <td>Batches writes for database efficiency</td>
                        <td><span class="badge badge-success">Active</span></td>
                    </tr>
                    <tr>
                        <td>CacheManager.js</td>
                        <td>In-memory cache with automatic eviction</td>
                        <td><span class="badge badge-success">Active</span></td>
                    </tr>
                </table>
            </section>

            <!-- ARCHITECTURE/FRAMEWORK SECTION -->
            <section id="framework">
                <h2>üèóÔ∏è Architecture & Design Framework</h2>

                <h3>Architectural Patterns</h3>

                <div class="feature-grid">
                    <div class="feature-card">
                        <h4>Event-Driven Architecture</h4>
                        <p>Central event bus enables loose coupling between components. Events like <code>message.processed</code>, <code>message.error</code>, and <code>relay.message</code> coordinate actions across modules.</p>
                    </div>
                    <div class="feature-card">
                        <h4>Middleware Pipeline</h4>
                        <p>Message processing uses a middleware pattern similar to Express. Each middleware can transform messages and pass control to the next.</p>
                    </div>
                    <div class="feature-card">
                        <h4>Component-Based Design</h4>
                        <p>All major modules inherit from BaseComponent, providing consistent initialization, shutdown, and logging interfaces.</p>
                    </div>
                    <div class="feature-card">
                        <h4>Singleton Pattern</h4>
                        <p>ConfigManager, eventBus, and dataStore use singleton pattern to ensure single instance across the application.</p>
                    </div>
                </div>

                <h3>System Architecture Diagram</h3>
                <div class="mermaid">
graph TB
    subgraph "External Systems"
        MQTT[MQTT Broker]
        DB[(MySQL Database)]
        WS_CLIENT[WebSocket Clients]
        HTTP_CALLBACK[HTTP Callback URLs]
    end

    subgraph "IoT Middleware v3"
        subgraph "Entry Point"
            SERVER[server.js<br/>Express HTTP Server]
        end

        subgraph "Core Application"
            APP[Application.js<br/>Component Orchestrator]
        end

        subgraph "MQTT Layer"
            MQTT_CLIENT[MQTTClient.js<br/>Connection Manager]
            TOPIC_MGR[TopicManager.js<br/>Topic Parser]
            MSG_RELAY[MessageRelay.js<br/>Republisher]
        end

        subgraph "Processing Layer"
            MSG_PROC[MessageProcessor.js<br/>Middleware Pipeline]
            NORMALIZER[Normalizers<br/>Data Transform]
            EVENT_BUS[EventBus.js<br/>Event Emitter]
        end

        subgraph "Storage Layer"
            CACHE[CacheManager.js<br/>In-Memory Cache]
            DATA_STORE[DataStore.js<br/>Memory Store]
            WRITE_BUF[WriteBuffer.js<br/>Batch Buffer]
            DB_MGR[DatabaseManager.js<br/>MySQL Pool]
        end

        subgraph "API Layer"
            REST_API[routes/api.js<br/>REST Endpoints]
            SYS_API[routes/system.js<br/>System Metrics]
            WS_SERVER[WebSocketServer.js<br/>WS Broadcaster]
            CB_MGR[CallbackManager.js<br/>HTTP Callbacks]
        end
    end

    %% External connections
    MQTT -->|Subscribe| MQTT_CLIENT
    MQTT_CLIENT -->|Publish Relay| MQTT
    WS_CLIENT <-->|WebSocket| WS_SERVER
    HTTP_CALLBACK <--| POST| CB_MGR
    DB_MGR <-->|SQL| DB

    %% Internal flow
    SERVER --> APP
    APP --> MQTT_CLIENT
    APP --> WS_SERVER
    APP --> CB_MGR
    
    MQTT_CLIENT --> TOPIC_MGR
    MQTT_CLIENT --> MSG_PROC
    
    MSG_PROC --> NORMALIZER
    MSG_PROC --> EVENT_BUS
    
    EVENT_BUS --> CACHE
    EVENT_BUS --> DATA_STORE
    EVENT_BUS --> WRITE_BUF
    EVENT_BUS --> WS_SERVER
    EVENT_BUS --> CB_MGR
    EVENT_BUS --> MSG_RELAY
    
    WRITE_BUF --> DB_MGR
    
    REST_API --> DATA_STORE
    REST_API --> DB_MGR
    SYS_API --> WS_SERVER
    SYS_API --> WRITE_BUF

    style MQTT fill:#e1f5ff
    style DB fill:#e1f5ff
    style WS_CLIENT fill:#e1f5ff
    style HTTP_CALLBACK fill:#e1f5ff
    style EVENT_BUS fill:#fff9c4
    style APP fill:#c8e6c9
                </div>

                <h3>Component Lifecycle</h3>
                <div class="mermaid">
sequenceDiagram
    participant S as server.js
    participant A as Application
    participant C as Components
    participant E as EventBus

    S->>A: new Application({server, config})
    S->>A: initialize()
    
    A->>A: initializeComponents()
    
    loop For Each Component
        A->>C: new Component(options)
        A->>C: initialize()
        C-->>A: initialized
        A->>A: components.set(name, component)
    end
    
    A->>A: setupEventListeners()
    A->>E: Subscribe to events
    
    A->>C: Subscribe to MQTT topics
    
    Note over A,C: System Running
    
    S->>A: shutdown() on SIGTERM/SIGINT
    
    loop For Each Component (Reverse Order)
        A->>C: shutdown()
        C-->>A: shut down
    end
    
    A->>A: components.clear()
                </div>

                <h3>Design Principles</h3>

                <div class="info-box">
                    <h4>1. Separation of Concerns</h4>
                    <p>Each module has a single, well-defined responsibility:</p>
                    <ul>
                        <li><strong>MQTTClient:</strong> Only handles MQTT connection and subscriptions</li>
                        <li><strong>MessageProcessor:</strong> Only manages the processing pipeline</li>
                        <li><strong>DatabaseManager:</strong> Only handles database operations</li>
                        <li><strong>Application:</strong> Orchestrates components without business logic</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h4>2. Loose Coupling via Events</h4>
                    <p>Components don't call each other directly. Instead, they emit and listen to events:</p>
                    <ul>
                        <li>MessageProcessor emits <code>message.processed</code></li>
                        <li>Multiple components listen and react independently</li>
                        <li>Easy to add/remove features without modifying existing code</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h4>3. Configuration-Driven</h4>
                    <p>Features can be enabled/disabled via configuration without code changes:</p>
                    <ul>
                        <li>Database persistence: <code>database.enabled</code></li>
                        <li>Message relay: <code>messageRelay.enabled</code></li>
                        <li>HTTP callbacks: <code>callbacks.enabled</code></li>
                    </ul>
                </div>

                <div class="info-box">
                    <h4>4. Fail-Safe Operations</h4>
                    <ul>
                        <li>Write buffer retries failed database operations</li>
                        <li>Callback manager has exponential backoff</li>
                        <li>MQTT client automatically reconnects</li>
                        <li>Each component handles errors independently</li>
                    </ul>
                </div>

                <h3>BaseComponent Pattern</h3>
                <p>All major components extend BaseComponent for consistency:</p>
                <pre><code>class MyComponent extends BaseComponent {
    constructor(options) {
        super(options);
        // Component-specific initialization
    }

    async initialize() {
        // Setup logic
        // Must be implemented by subclass
    }

    shutdown() {
        // Cleanup logic
        // Default implementation in base class
    }
}</code></pre>

                <p><strong>Benefits:</strong></p>
                <ul>
                    <li>Consistent interface across all components</li>
                    <li>Automatic access to config and logger</li>
                    <li>Predictable lifecycle management</li>
                    <li>Easy to add new components</li>
                </ul>
            </section>

            <!-- MESSAGE FLOW SECTION -->
            <section id="message-flow">
                <h2>üîÑ Message Processing Flow</h2>

                <h3>Complete Message Journey</h3>
                <div class="mermaid">
graph TD
    A[MQTT Broker] -->|1. Message Published| B[MQTTClient]
    B -->|2. Topic Match| C{TopicManager<br/>Validate}
    C -->|Invalid| Z[Log & Drop]
    C -->|Valid| D[Parse JSON Payload]
    D -->|3. Parse Components| E[MessageProcessor<br/>Start Pipeline]
    
    E -->|4. Middleware| F[TemperatureNormalizer]
    F -->|5. Transform Data| G{Normalized Message}
    
    G -->|6. Call next| H[MessageProcessor<br/>Pipeline Complete]
    H -->|7. Emit Event| I[EventBus<br/>message.processed]
    
    I -->|8. Broadcast| J[WebSocketServer]
    J -->|9. Send| K[Connected WS Clients]
    
    I -->|10. Cache| L[CacheManager]
    L -->|Store Latest| M[(In-Memory Cache)]
    
    I -->|11. Store| N[DataStore]
    N -->|Append| O[(In-Memory Store)]
    
    I -->|12. Buffer| P[WriteBuffer]
    P -->|Batch Write| Q{Buffer Full?}
    Q -->|Yes or Timeout| R[DatabaseManager]
    Q -->|No| P
    R -->|13. Batch Insert| S[(MySQL Database)]
    
    I -->|14. Relay Check| T{MessageRelay<br/>Enabled?}
    T -->|Yes| U[Build New Topic]
    U -->|15. Emit relay.message| V[EventBus]
    V -->|16. Publish| W[MQTTClient]
    W -->|17. Publish| A
    
    I -->|18. Callback Check| X{CallbackManager<br/>Enabled?}
    X -->|Yes & URLs Registered| Y[HTTP POST]
    Y -->|With Retry| AA[External Service]

    style A fill:#e1f5ff
    style K fill:#e1f5ff
    style S fill:#e1f5ff
    style AA fill:#e1f5ff
    style I fill:#fff9c4
    style G fill:#c8e6c9
                </div>

                <h3>Detailed Step-by-Step Flow</h3>

                <div class="feature-card">
                    <h4>Step 1-2: Message Reception</h4>
                    <p><strong>MQTTClient receives message:</strong></p>
                    <ul>
                        <li>Client is subscribed to topics like <code>sensors/#</code>, <code>devices/#</code></li>
                        <li>On message arrival, client triggers registered handlers</li>
                        <li>Topic is matched against subscription patterns</li>
                    </ul>
                </div>

                <div class="feature-card">
                    <h4>Step 3-4: Topic Validation & Parsing</h4>
                    <p><strong>TopicManager validates and parses:</strong></p>
                    <pre><code>// Topic: sensors/gateway123/temperature
{
  category: "sensors",
  gatewayId: "gateway123",
  type: "temperature",
  remaining: ""
}</code></pre>
                    <p>Invalid topics are logged and dropped.</p>
                </div>

                <div class="feature-card">
                    <h4>Step 5-6: Middleware Pipeline</h4>
                    <p><strong>MessageProcessor applies middleware:</strong></p>
                    <pre><code>messageProcessor.use(async (message, context, next) => {
    const normalized = normalizeTemperature(message, context.topic);
    Object.assign(message, normalized);
    await next();
});</code></pre>
                    <p>Multiple middleware can be chained for complex transformations.</p>
                </div>

                <div class="feature-card">
                    <h4>Step 7-8: Event Emission</h4>
                    <p><strong>EventBus broadcasts to all listeners:</strong></p>
                    <pre><code>eventBus.emit('message.processed', normalizedMessage);</code></pre>
                    <p>All subscribed components react independently and concurrently.</p>
                </div>

                <div class="feature-card">
                    <h4>Step 9-10: Real-time Broadcasting</h4>
                    <p><strong>WebSocketServer sends to all connected clients:</strong></p>
                    <ul>
                        <li>Serializes message to JSON</li>
                        <li>Broadcasts to all connected WebSocket clients</li>
                        <li>Handles client disconnections gracefully</li>
                    </ul>
                </div>

                <div class="feature-card">
                    <h4>Step 11-12: Caching</h4>
                    <p><strong>CacheManager stores latest value:</strong></p>
                    <ul>
                        <li>Uses deviceId as key</li>
                        <li>Applies TTL (Time To Live)</li>
                        <li>Automatically evicts old entries when cache is full</li>
                    </ul>
                </div>

                <div class="feature-card">
                    <h4>Step 13-14: Buffered Database Write</h4>
                    <p><strong>WriteBuffer queues for batch insert:</strong></p>
                    <ul>
                        <li>Messages accumulate in buffer</li>
                        <li>Flush triggered by size threshold or time interval</li>
                        <li>Batch insert to database for efficiency</li>
                        <li>Retry logic for failed operations</li>
                        <li>Fallback to individual inserts if batch fails</li>
                    </ul>
                </div>

                <div class="feature-card">
                    <h4>Step 15-17: Message Relay (Optional)</h4>
                    <p><strong>MessageRelay republishes to new topic:</strong></p>
                    <ul>
                        <li>Checks if relay rules match message</li>
                        <li>Transforms topic according to pattern</li>
                        <li>Emits <code>relay.message</code> event</li>
                        <li>MQTTClient publishes to new topic</li>
                    </ul>
                    <pre><code>// Original: sensors/gateway123/temperature
// Relayed:  sensors/new/gateway123/temperature</code></pre>
                </div>

                <div class="feature-card">
                    <h4>Step 18-19: HTTP Callbacks (Optional)</h4>
                    <p><strong>CallbackManager notifies external services:</strong></p>
                    <ul>
                        <li>Sends HTTP POST with message payload</li>
                        <li>Implements retry logic with exponential backoff</li>
                        <li>Configurable retry limits and delays</li>
                    </ul>
                </div>

                <h3>Error Handling Flow</h3>
                <div class="mermaid">
graph TD
    A[Error Occurs] --> B{Error Type}
    
    B -->|MQTT Connection| C[MQTTClient Reconnect]
    C -->|Auto Retry| D[Reconnect with Backoff]
    
    B -->|Database Write| E[WriteBuffer Retry]
    E -->|Max Retries Exceeded| F[Individual Saves]
    F -->|Still Fails| G[Log Error & Continue]
    
    B -->|Message Processing| H[Emit message.error]
    H --> I[Logger Records Error]
    I --> J[Continue Processing Next]
    
    B -->|HTTP Callback| K[CallbackManager Retry]
    K -->|Exponential Backoff| L{Max Retries?}
    L -->|Yes| M[Give Up & Log]
    L -->|No| K
    
    B -->|WebSocket Send| N[Remove Dead Client]
    N --> O[Continue to Other Clients]

    style A fill:#ffcdd2
    style G fill:#fff9c4
    style M fill:#fff9c4
                </div>

                <h3>Performance Optimizations</h3>
                <ul>
                    <li><strong>Batch Writes:</strong> Database writes are batched to reduce I/O operations</li>
                    <li><strong>Connection Pooling:</strong> MySQL connections are pooled and reused</li>
                    <li><strong>In-Memory Cache:</strong> Reduces database queries for latest data</li>
                    <li><strong>Async Operations:</strong> All I/O operations are non-blocking</li>
                    <li><strong>Event-Driven:</strong> Components process independently without blocking</li>
                </ul>
            </section>

            <!-- DEPENDENCIES SECTION -->
            <section id="dependencies">
                <h2>üì¶ Dependencies & Import Relationships</h2>

                <h3>NPM Package Dependencies</h3>
                <table>
                    <tr>
                        <th>Package</th>
                        <th>Version</th>
                        <th>Purpose</th>
                        <th>Type</th>
                    </tr>
                    <tr>
                        <td>express</td>
                        <td>^4.19.0</td>
                        <td>Web framework for REST API</td>
                        <td><span class="badge badge-primary">Core</span></td>
                    </tr>
                    <tr>
                        <td>mqtt</td>
                        <td>^5.3.0</td>
                        <td>MQTT protocol client</td>
                        <td><span class="badge badge-primary">Core</span></td>
                    </tr>
                    <tr>
                        <td>mysql2</td>
                        <td>^3.9.7</td>
                        <td>MySQL database driver with promises</td>
                        <td><span class="badge badge-primary">Core</span></td>
                    </tr>
                    <tr>
                        <td>ws</td>
                        <td>^8.5.0</td>
                        <td>WebSocket server implementation</td>
                        <td><span class="badge badge-primary">Core</span></td>
                    </tr>
                    <tr>
                        <td>dotenv</td>
                        <td>^16.0.0</td>
                        <td>Environment variable management</td>
                        <td><span class="badge badge-success">Utility</span></td>
                    </tr>
                    <tr>
                        <td>node-fetch</td>
                        <td>^2.6.7</td>
                        <td>HTTP client for callbacks</td>
                        <td><span class="badge badge-info">Optional</span></td>
                    </tr>
                    <tr>
                        <td>compression</td>
                        <td>^1.7.4</td>
                        <td>Response compression middleware</td>
                        <td><span class="badge badge-success">Utility</span></td>
                    </tr>
                    <tr>
                        <td>express-rate-limit</td>
                        <td>^6.7.0</td>
                        <td>Rate limiting middleware</td>
                        <td><span class="badge badge-success">Utility</span></td>
                    </tr>
                    <tr>
                        <td>nodemon</td>
                        <td>^3.1.0</td>
                        <td>Development auto-reload</td>
                        <td><span class="badge badge-warning">Dev</span></td>
                    </tr>
                </table>

                <h3>Module Import Hierarchy</h3>
                <div class="mermaid">
graph TD
    subgraph "Entry Point"
        SERVER[server.js]
    end

    subgraph "Core Singletons"
        CONFIG[ConfigManager]
        LOGGER[logger]
        EVENT[eventBus]
        DSTORE[dataStore]
    end

    subgraph "Base Classes"
        BASE[BaseComponent]
    end

    subgraph "Main Application"
        APP[Application.js]
    end

    subgraph "MQTT Modules"
        MQTT[MQTTClient]
        TOPIC[TopicManager]
        RELAY[MessageRelay]
    end

    subgraph "Processing"
        PROC[MessageProcessor]
        NORM[temperatureNormalizer]
    end

    subgraph "Storage"
        DB[DatabaseManager]
        CACHE[CacheManager]
        WBUF[WriteBuffer]
    end

    subgraph "API"
        WS[WebSocketServer]
        CB[CallbackManager]
    end

    subgraph "Routes"
        RAPI[routes/api]
        RSYS[routes/system]
        RIDX[routes/index]
    end

    SERVER --> CONFIG
    SERVER --> LOGGER
    SERVER --> APP
    SERVER --> RAPI
    SERVER --> RSYS
    SERVER --> RIDX

    APP --> BASE
    APP --> CONFIG
    APP --> MQTT
    APP --> TOPIC
    APP --> RELAY
    APP --> PROC
    APP --> DB
    APP --> CACHE
    APP --> WBUF
    APP --> WS
    APP --> CB
    APP --> DSTORE
    APP --> EVENT
    APP --> NORM

    MQTT --> BASE
    TOPIC --> BASE
    RELAY --> BASE
    DB --> BASE
    CACHE --> BASE
    WBUF --> BASE
    WS --> BASE
    CB --> BASE
    PROC --> EVENT
    DSTORE --> BASE

    BASE --> CONFIG
    BASE --> LOGGER

    RELAY --> EVENT
    CB --> EVENT
    WS --> EVENT
    DSTORE --> EVENT

    WBUF --> DB

    RAPI --> DSTORE
    RAPI --> DB
    RSYS --> WS
    RSYS --> WBUF

    style SERVER fill:#c8e6c9
    style CONFIG fill:#fff9c4
    style LOGGER fill:#fff9c4
    style EVENT fill:#fff9c4
    style BASE fill:#e1bee7
                </div>

                <h3>Dependency Injection Pattern</h3>
                <p>Components receive their dependencies through constructor options:</p>
                <pre><code>// WriteBuffer depends on DatabaseManager
const writeBuffer = new WriteBuffer({ 
    dbStore: dbManager  // Injected dependency
});

// WebSocketServer depends on HTTP server
const wsServer = new WebSocketServer({ 
    server: httpServer  // Injected dependency
});</code></pre>

                <h3>Import Relationships</h3>

                <h4>server.js imports:</h4>
                <pre><code>const express = require("express");
const dotenv = require("dotenv");
const logger = require("./utils/logger");
const Application = require("./modules/Application");
const apiRoutes = require("./routes/api");
const indexRoutes = require("./routes/index");
const systemRoutes = require("./routes/system");</code></pre>

                <h4>Application.js imports:</h4>
                <pre><code>const BaseComponent = require('./core/BaseComponent');
const configManager = require('../config/ConfigManager');
const MQTTClient = require('./mqtt/MQTTClient');
const TopicManager = require('./mqtt/TopicManager');
const MessageProcessor = require('./core/messageProcessor');
const DatabaseManager = require('./database/DatabaseManager');
const WriteBuffer = require('./storage/WriteBuffer');
const CacheManager = require('./storage/CacheManager');
const MessageRelay = require('./mqtt/messageRelay');
const WebSocketServer = require('./api/WebSocketServer');
const CallbackManager = require('./api/CallbackManager');
const dataStore = require('./storage/dataStore');
const eventBus = require('./core/eventBus');
const normalizeTemperature = require('./normalizers/temperatureNormalizer');</code></pre>

                <h4>BaseComponent imports:</h4>
                <pre><code>const configManager = require('../../config/ConfigManager');
const logger = require('../../utils/logger');</code></pre>

                <div class="info-box">
                    <h4>üîç Key Observations</h4>
                    <ul>
                        <li><strong>Singleton Pattern:</strong> ConfigManager, eventBus, dataStore are singletons - imported once, used everywhere</li>
                        <li><strong>Inheritance Chain:</strong> Most components extend BaseComponent for consistent interface</li>
                        <li><strong>Loose Coupling:</strong> EventBus prevents direct dependencies between components</li>
                        <li><strong>No Circular Dependencies:</strong> Clean dependency tree with no cycles</li>
                    </ul>
                </div>

                <h3>External Service Dependencies</h3>
                <div class="mermaid">
graph LR
    APP[IoT Middleware]
    
    APP <-->|MQTT Protocol| MQTT[MQTT Broker<br/>Mosquitto/EMQX]
    APP <-->|SQL| DB[(MySQL 8.0+<br/>Database)]
    APP <-->|WebSocket| WS[WebSocket Clients<br/>Browsers/Apps]
    APP -->|HTTP POST| EXT[External Services<br/>via Callbacks]
    
    style APP fill:#c8e6c9
    style MQTT fill:#e1f5ff
    style DB fill:#e1f5ff
    style WS fill:#e1f5ff
    style EXT fill:#e1f5ff
                </div>

                <table>
                    <tr>
                        <th>External Service</th>
                        <th>Protocol</th>
                        <th>Purpose</th>
                        <th>Required?</th>
                    </tr>
                    <tr>
                        <td>MQTT Broker</td>
                        <td>MQTT 3.1.1/5.0</td>
                        <td>Message ingestion from IoT devices</td>
                        <td><span class="badge badge-danger">Required</span></td>
                    </tr>
                    <tr>
                        <td>MySQL Database</td>
                        <td>MySQL Protocol</td>
                        <td>Persistent message storage</td>
                        <td><span class="badge badge-info">Optional</span></td>
                    </tr>
                    <tr>
                        <td>WebSocket Clients</td>
                        <td>WebSocket</td>
                        <td>Real-time data consumption</td>
                        <td><span class="badge badge-info">Optional</span></td>
                    </tr>
                    <tr>
                        <td>External APIs</td>
                        <td>HTTP/HTTPS</td>
                        <td>Callback notifications</td>
                        <td><span class="badge badge-info">Optional</span></td>
                    </tr>
                </table>
            </section>

            <!-- SCALABILITY SECTION -->
            <section id="scalability">
                <h2>üìà Scalability Considerations</h2>

                <h3>Current Architecture Scalability</h3>

                <div class="feature-grid">
                    <div class="feature-card">
                        <h4>‚úÖ Vertical Scaling</h4>
                        <p><strong>Well Supported</strong></p>
                        <ul>
                            <li>Node.js single-threaded but async I/O</li>
                            <li>Connection pooling for database</li>
                            <li>In-memory caching reduces DB load</li>
                            <li>Batch writes optimize database throughput</li>
                        </ul>
                    </div>
                    <div class="feature-card">
                        <h4>‚ö†Ô∏è Horizontal Scaling</h4>
                        <p><strong>Needs Consideration</strong></p>
                        <ul>
                            <li>Single MQTT client connection</li>
                            <li>In-memory state not shared</li>
                            <li>No built-in load balancing</li>
                            <li>WebSocket clients tied to single instance</li>
                        </ul>
                    </div>
                </div>

                <h3>Scalability Bottlenecks</h3>

                <div class="warning-box">
                    <h4>1. Single MQTT Client Instance</h4>
                    <p><strong>Problem:</strong> Only one connection to MQTT broker</p>
                    <p><strong>Impact:</strong> Limited by single TCP connection bandwidth</p>
                    <p><strong>Solution:</strong></p>
                    <ul>
                        <li>Implement connection pooling for MQTT</li>
                        <li>Use MQTT shared subscriptions ($share)</li>
                        <li>Deploy multiple middleware instances with load balancer</li>
                    </ul>
                </div>

                <div class="warning-box">
                    <h4>2. In-Memory State</h4>
                    <p><strong>Problem:</strong> Cacheand dataStore are in-memory, not shared across instances</p>
                    <p><strong>Impact:</strong> Each instance has different state, data inconsistency</p>
                    <p><strong>Solution:</strong></p>
                    <ul>
                        <li>Use Redis for shared caching layer</li>
                        <li>Store all data in database, use cache as read-through</li>
                        <li>Accept eventual consistency in distributed setup</li>
                    </ul>
                </div>

                <div class="warning-box">
                    <h4>3. WebSocket Sticky Sessions</h4>
                    <p><strong>Problem:</strong> WebSocket connections tied to single server instance</p>
                    <p><strong>Impact:</strong> Load balancing requires sticky sessions</p>
                    <p><strong>Solution:</strong></p>
                    <ul>
                        <li>Use Redis pub/sub for cross-instance broadcasting</li>
                        <li>Implement WebSocket adapter (e.g., socket.io with redis adapter)</li>
                        <li>Configure load balancer with sticky sessions</li>
                    </ul>
                </div>

                <h3>Next Steps for Scalability</h3>
                
                <div class="success-box">
                    <h4>‚ú?Already Implemented</h4>
                    <ul>
                        <li>Async/non-blocking I/O throughout</li>
                        <li>Database connection pooling</li>
                        <li>Batch writes for efficiency</li>
                        <li>Event-driven loose coupling</li>
                        <li>Configurable buffer sizes</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h4>üéØ Recommendations for Production Scale</h4>
                    <ol>
                        <li><strong>Short Term:</strong> Increase database pool size, optimize buffer settings</li>
                        <li><strong>Medium Term:</strong> Add Redis for shared cache, implement load balancing</li>
                        <li><strong>Long Term:</strong> Message queue integration, microservices architecture</li>
                    </ol>
                </div>

                <p><strong>Current Capacity Estimates:</strong></p>
                <ul>
                    <li>Messages/Second: ~1,000/s (single instance)</li>
                    <li>Concurrent Devices: ~5,000 devices</li>
                    <li>WebSocket Clients: ~100 clients</li>
                    <li>With scaling: 10x-100x improvement possible</li>
                </ul>
            </section>
        </div>

        <footer>
            <h3>IoT Middleware v3.0.0</h3>
            <p>High-Performance MQTT to REST API Bridge</p>
            <p style="margin-top: 10px;">
                <a href="https://github.com/dalelaibeyond/iot-middleware" style="color: #667eea;">View on GitHub</a>
            </p>
            <p style="margin-top: 20px; opacity: 0.8; font-size: 0.9em;">
                ¬© 2025 IoT Middleware Project | Documentation generated: October 1, 2025
            </p>
        </footer>
    </div>

    <script>
        // Initialize Mermaid
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            }
        });

        // Smooth scrolling for navigation links
        document.querySelectorAll('nav a').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Highlight current section in navigation
        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('section');
            const navLinks = document.querySelectorAll('nav a');
            
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (scrollY >= (sectionTop - 100)) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.style.background = '';
                link.style.color = '';
                if (link.getAttribute('href') === `#${current}`) {
                    link.style.background = '#667eea';
                    link.style.color = 'white';
                }
            });
        });
    </script>
</body>
</html>
and dataStore are in-memory, not shared across instances</p>
                    <p><strong>Impact:</strong> Each instance has different state, data inconsistency</p>
                    <p><strong>Solution:</strong></p>
                    <ul>
                        <li>Use Redis for shared caching layer</li>
                        <li>Store all data in database, use cache as read-through</li>
                        <li>Accept eventual consistency in distributed setup</li>
                    </ul>
                </div>

                <div class="warning-box">
                    <h4>3. WebSocket Sticky Sessions</h4>
                    <p><strong>Problem:</strong> WebSocket connections tied to single server instance</p>
                    <p><strong>Impact:</strong> Load balancing requires sticky sessions</p>
                    <p><strong>Solution:</strong></p>
                    <ul>
                        <li>Use Redis pub/sub for cross-instance broadcasting</li>
                        <li>Implement WebSocket adapter (e.g., socket.io with redis adapter)</li>
                        <li>Configure load balancer with sticky sessions</li>
                    </ul>
                </div>

                <h3>Next Steps for Scalability</h3>
                
                <div class="success-box">
                    <h4>‚ú?Already Implemented</h4>
                    <ul>
                        <li>Async/non-blocking I/O throughout</li>
                        <li>Database connection pooling</li>
                        <li>Batch writes for efficiency</li>
                        <li>Event-driven loose coupling</li>
                        <li>Configurable buffer sizes</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h4>üéØ Recommendations for Production Scale</h4>
                    <ol>
                        <li><strong>Short Term:</strong> Increase database pool size, optimize buffer settings</li>
                        <li><strong>Medium Term:</strong> Add Redis for shared cache, implement load balancing</li>
                        <li><strong>Long Term:</strong> Message queue integration, microservices architecture</li>
                    </ol>
                </div>

                <p><strong>Current Capacity Estimates:</strong></p>
                <ul>
                    <li>Messages/Second: ~1,000/s (single instance)</li>
                    <li>Concurrent Devices: ~5,000 devices</li>
                    <li>WebSocket Clients: ~100 clients</li>
                    <li>With scaling: 10x-100x improvement possible</li>
                </ul>
            </section>
        </div>

        <footer>
            <h3>IoT Middleware v3.0.0</h3>
            <p>High-Performance MQTT to REST API Bridge</p>
            <p style="margin-top: 10px;">
                <a href="https://github.com/dalelaibeyond/iot-middleware" style="color: #667eea;">View on GitHub</a>
            </p>
            <p style="margin-top: 20px; opacity: 0.8; font-size: 0.9em;">
                ¬© 2025 IoT Middleware Project | Documentation generated: October 1, 2025
            </p>
        </footer>
    </div>

    <script>
        // Initialize Mermaid
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            }
        });

        // Smooth scrolling for navigation links
        document.querySelectorAll('nav a').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Highlight current section in navigation
        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('section');
            const navLinks = document.querySelectorAll('nav a');
            
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (scrollY >= (sectionTop - 100)) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.style.background = '';
                link.style.color = '';
                if (link.getAttribute('href') === `#${current}`) {
                    link.style.background = '#667eea';
                    link.style.color = 'white';
                }
            });
        });
    </script>
</body>
</html>
and dataStore are in-memory, not shared across instances</p>
                    <p><strong>Impact:</strong> Each instance has different state, data inconsistency</p>
                    <p><strong>Solution:</strong></p>
                    <ul>
                        <li>Use Redis for shared caching layer</li>
                        <li>Store all data in database, use cache as read-through</li>
                        <li>Accept eventual consistency in distributed setup</li>
                    </ul>
                </div>

                <div class="warning-box">
                    <h4>3. WebSocket Sticky Sessions</h4>
                    <p><strong>Problem:</strong> WebSocket connections tied to single server instance</p>
                    <p><strong>Impact:</strong> Load balancing requires sticky sessions</p>
                    <p><strong>Solution:</strong></p>
                    <ul>
                        <li>Use Redis pub/sub for cross-instance broadcasting</li>
                        <li>Implement WebSocket adapter (e.g., socket.io with redis adapter)</li>
                        <li>Configure load balancer with sticky sessions</li>
                    </ul>
                </div>

                <h3>Next Steps for Scalability</h3>
                
                <div class="success-box">
                    <h4>‚ú?Already Implemented</h4>
                    <ul>
                        <li>Async/non-blocking I/O throughout</li>
                        <li>Database connection pooling</li>
                        <li>Batch writes for efficiency</li>
                        <li>Event-driven loose coupling</li>
                        <li>Configurable buffer sizes</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h4>üéØ Recommendations for Production Scale</h4>
                    <ol>
                        <li><strong>Short Term:</strong> Increase database pool size, optimize buffer settings</li>
                        <li><strong>Medium Term:</strong> Add Redis for shared cache, implement load balancing</li>
                        <li><strong>Long Term:</strong> Message queue integration, microservices architecture</li>
                    </ol>
                </div>

                <p><strong>Current Capacity Estimates:</strong></p>
                <ul>
                    <li>Messages/Second: ~1,000/s (single instance)</li>
                    <li>Concurrent Devices: ~5,000 devices</li>
                    <li>WebSocket Clients: ~100 clients</li>
                    <li>With scaling: 10x-100x improvement possible</li>
                </ul>
            </section>
        </div>

        <footer>
            <h3>IoT Middleware v3.0.0</h3>
            <p>High-Performance MQTT to REST API Bridge</p>
            <p style="margin-top: 10px;">
                <a href="https://github.com/dalelaibeyond/iot-middleware" style="color: #667eea;">View on GitHub</a>
            </p>
            <p style="margin-top: 20px; opacity: 0.8; font-size: 0.9em;">
                ¬© 2025 IoT Middleware Project | Documentation generated: October 1, 2025
            </p>
        </footer>
    </div>

    <script>
        // Initialize Mermaid
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            }
        });

        // Smooth scrolling for navigation links
        document.querySelectorAll('nav a').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Highlight current section in navigation
        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('section');
            const navLinks = document.querySelectorAll('nav a');
            
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (scrollY >= (sectionTop - 100)) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.style.background = '';
                link.style.color = '';
                if (link.getAttribute('href') === `#${current}`) {
                    link.style.background = '#667eea';
                    link.style.color = 'white';
                }
            });
        });
    </script>
</body>
</html>
and dataStore are in-memory, not shared across instances</p>
                    <p><strong>Impact:</strong> Each instance has different state, data inconsistency</p>
                    <p><strong>Solution:</strong></p>
                    <ul>
                        <li>Use Redis for shared caching layer</li>
                        <li>Store all data in database, use cache as read-through</li>
                        <li>Accept eventual consistency in distributed setup</li>
                    </ul>
                </div>

                <div class="warning-box">
                    <h4>3. WebSocket Sticky Sessions</h4>
                    <p><strong>Problem:</strong> WebSocket connections tied to single server instance</p>
                    <p><strong>Impact:</strong> Load balancing requires sticky sessions</p>
                    <p><strong>Solution:</strong></p>
                    <ul>
                        <li>Use Redis pub/sub for cross-instance broadcasting</li>
                        <li>Implement WebSocket adapter (e.g., socket.io with redis adapter)</li>
                        <li>Configure load balancer with sticky sessions</li>
                    </ul>
                </div>

                <h3>Next Steps for Scalability</h3>
                
                <div class="success-box">
                    <h4>‚ú?Already Implemented</h4>
                    <ul>
                        <li>Async/non-blocking I/O throughout</li>
                        <li>Database connection pooling</li>
                        <li>Batch writes for efficiency</li>
                        <li>Event-driven loose coupling</li>
                        <li>Configurable buffer sizes</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h4>üéØ Recommendations for Production Scale</h4>
                    <ol>
                        <li><strong>Short Term:</strong> Increase database pool size, optimize buffer settings</li>
                        <li><strong>Medium Term:</strong> Add Redis for shared cache, implement load balancing</li>
                        <li><strong>Long Term:</strong> Message queue integration, microservices architecture</li>
                    </ol>
                </div>

                <p><strong>Current Capacity Estimates:</strong></p>
                <ul>
                    <li>Messages/Second: ~1,000/s (single instance)</li>
                    <li>Concurrent Devices: ~5,000 devices</li>
                    <li>WebSocket Clients: ~100 clients</li>
                    <li>With scaling: 10x-100x improvement possible</li>
                </ul>
            </section>
        </div>

        <footer>
            <h3>IoT Middleware v3.0.0</h3>
            <p>High-Performance MQTT to REST API Bridge</p>
            <p style="margin-top: 10px;">
                <a href="https://github.com/dalelaibeyond/iot-middleware" style="color: #667eea;">View on GitHub</a>
            </p>
            <p style="margin-top: 20px; opacity: 0.8; font-size: 0.9em;">
                ¬© 2025 IoT Middleware Project | Documentation generated: October 1, 2025
            </p>
        </footer>
    </div>

    <script>
        // Initialize Mermaid
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            }
        });

        // Smooth scrolling for navigation links
        document.querySelectorAll('nav a').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Highlight current section in navigation
        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('section');
            const navLinks = document.querySelectorAll('nav a');
            
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (scrollY >= (sectionTop - 100)) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.style.background = '';
                link.style.color = '';
                if (link.getAttribute('href') === `#${current}`) {
                    link.style.background = '#667eea';
                    link.style.color = 'white';
                }
            });
        });
    </script>
</body>
</html>
