and dataStore are in-memory, not shared across instances</p>
                    <p><strong>Impact:</strong> Each instance has different state, data inconsistency</p>
                    <p><strong>Solution:</strong></p>
                    <ul>
                        <li>Use Redis for shared caching layer</li>
                        <li>Store all data in database, use cache as read-through</li>
                        <li>Accept eventual consistency in distributed setup</li>
                    </ul>
                </div>

                <div class="warning-box">
                    <h4>3. WebSocket Sticky Sessions</h4>
                    <p><strong>Problem:</strong> WebSocket connections tied to single server instance</p>
                    <p><strong>Impact:</strong> Load balancing requires sticky sessions</p>
                    <p><strong>Solution:</strong></p>
                    <ul>
                        <li>Use Redis pub/sub for cross-instance broadcasting</li>
                        <li>Implement WebSocket adapter (e.g., socket.io with redis adapter)</li>
                        <li>Configure load balancer with sticky sessions</li>
                    </ul>
                </div>

                <h3>Next Steps for Scalability</h3>
                
                <div class="success-box">
                    <h4>âœ… Already Implemented</h4>
                    <ul>
                        <li>Async/non-blocking I/O throughout</li>
                        <li>Database connection pooling</li>
                        <li>Batch writes for efficiency</li>
                        <li>Event-driven loose coupling</li>
                        <li>Configurable buffer sizes</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h4>ðŸŽ¯ Recommendations for Production Scale</h4>
                    <ol>
                        <li><strong>Short Term:</strong> Increase database pool size, optimize buffer settings</li>
                        <li><strong>Medium Term:</strong> Add Redis for shared cache, implement load balancing</li>
                        <li><strong>Long Term:</strong> Message queue integration, microservices architecture</li>
                    </ol>
                </div>

                <p><strong>Current Capacity Estimates:</strong></p>
                <ul>
                    <li>Messages/Second: ~1,000/s (single instance)</li>
                    <li>Concurrent Devices: ~5,000 devices</li>
                    <li>WebSocket Clients: ~100 clients</li>
                    <li>With scaling: 10x-100x improvement possible</li>
                </ul>
            </section>
        </div>

        <footer>
            <h3>IoT Middleware v3.0.0</h3>
            <p>High-Performance MQTT to REST API Bridge</p>
            <p style="margin-top: 10px;">
                <a href="https://github.com/dalelaibeyond/iot-middleware" style="color: #667eea;">View on GitHub</a>
            </p>
            <p style="margin-top: 20px; opacity: 0.8; font-size: 0.9em;">
                Â© 2025 IoT Middleware Project | Documentation generated: October 1, 2025
            </p>
        </footer>
    </div>

    <script>
        // Initialize Mermaid
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            }
        });

        // Smooth scrolling for navigation links
        document.querySelectorAll('nav a').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Highlight current section in navigation
        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('section');
            const navLinks = document.querySelectorAll('nav a');
            
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (scrollY >= (sectionTop - 100)) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.style.background = '';
                link.style.color = '';
                if (link.getAttribute('href') === `#${current}`) {
                    link.style.background = '#667eea';
                    link.style.color = 'white';
                }
            });
        });
    </script>
</body>
</html>
